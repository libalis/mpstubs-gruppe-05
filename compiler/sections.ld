/* Entry in our OS -- label 'startup_bsp' in file boot/startup.asm */
ENTRY(startup_bsp)

SECTIONS
 {
	/* start address of our kernel */
	. = 16M;

	/* This is a linker script defined "variable" (without value -- therefore
	 * better to be considered as a symbol), which can be referenced in the C++
	 * source code using `&___KERNEL_START___` (mind the reference operator!)
	 * to get a pointer to the current (virtual) memory position.
	 * However, a previous declaration with C linkage is required, e.g.
	 *     extern "C" void * ___KERNEL_START___;
	 * For more information have a look at
	 * https://sourceware.org/binutils/docs/ld/Source-Code-Reference.html
	 */
	___KERNEL_START___ = .;

	.boot :
	{
		/* Multiboot Header should be at the very beginning of the binary */
		*(.multiboot_header)
	}

	/* The (executable) machine code */
	.text :
	{
		*(.text .text.* .gnu.linkonce.t.*)
		*(.init)
		*(.fini)
	}

	/* Align to the next page border
	 * allowing the linker to mark the section above as [read and] executable
	 * while the following sections is just read-only. */
	. = ALIGN(0x1000);

	/* Start for application processors, relocated by APIC::init()
	 * to a below 1 MB address to boot from real mode.
	 *
	 * Please note:
	 * It is possible to let the linker place it at a below 1 MB address,
	 * while all the rest starts at 16 MB. This will work for multiboot
	 * compliant boot loader like GRUB and PXELINUX, however,
	 * the qemu boot loader cannot handle such ELF files (yet)...
	 * That's why we have to copy it ourself in the kernel */
	.setup_ap_seg ALIGN(0x10) :
	{
		___SETUP_AP_START__ = .;
		*(.setup_ap_seg)
	}
	___SETUP_AP_END__ = .;

	/* Read-only data */
	.rodata :
	{
		*(.rodata .rodata.* .gnu.linkonce.r.*)
		KEEP(*(.note.gnu.build-id))
	}

	/* Align to the next page border
	 * allowing the linker to mark the section below as [read and] writeable */
	. = ALIGN(0x1000);

	/* lists containing the start address of global constructors and destructors (generated by the compiler) */
	.preinit_array :
	{
		PROVIDE_HIDDEN (__preinit_array_start = .);
		KEEP (*(.preinit_array))
		PROVIDE_HIDDEN (__preinit_array_end = .);
	}
	.init_array :
	{
		PROVIDE_HIDDEN (__init_array_start = .);
		KEEP (*(SORT(.init_array.*)))
		KEEP (*(.init_array))
		PROVIDE_HIDDEN (__init_array_end = .);
	}
	.fini_array :
	{
		PROVIDE_HIDDEN (__fini_array_start = .);
		KEEP (*(SORT(.fini_array.*)))
		KEEP (*(.fini_array))
		PROVIDE_HIDDEN (__fini_array_end = .);
	}

	/* the data section containing initialized static variables
	* (writeable with a value not zero) */
	.data :
	{
		*(.data .data.* .gnu.linkonce.d.*)
		/* Global offset table */
		*(.got*)
		/* Exception Handling */
		*(.eh_frame*)
	}

	/* the bss (block starting symbol) section  containing uninitialized
	 * static variables (writeable with an initial value of zero);
	 * this section does not consume any memory in the binary */
	.bss :
	{
		*(.bss .bss.* .gnu.linkonce.b.*)
		*(COMMON)
	}

	___KERNEL_END___ = .;

	/* Sections which should not be included in the binary */
	/DISCARD/ :
	{
		*(.note)
		*(.comment)
		/* Debug information (commented out to keep it)
		*(.debug*)
		*/
	}
 }
